---
title: 'modComp study reward-effort task: planning intervention data '
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
# knitr options
knitr::opts_chunk$set(echo=FALSE, error=TRUE, warning=FALSE, message=FALSE, fig.align='center')

# load packages
packages <- c("rjson", "dplyr", "tidyverse", "tidyr", "reshape2", "ggpmisc", "patchwork", 
              "devtools", "wesanderson", "unikn", "lme4", "lmerTest", "emmeans", "rstatix", 
              "summarytools", "jtools")
if (length(setdiff(packages, rownames(installed.packages()))) > 0 ) {
  install.packages(setdiff(packages, rownames(installed.packages())))
}
lapply(packages, require, character.only=TRUE)

# load rainCloudPlot src code
source_url("https://raw.githubusercontent.com/RainCloudPlots/RainCloudPlots/master/tutorial_R/R_rainclouds.R")

# set wd
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

```{r specify_task}
## set-up where to look for data, and what task version to get
# where firebase raw output files have been downloaded to
data_dir <- "../data"
# what task version to filter for
task_ver <- "rew-eff-planning-1"               #"rew-eff-plannning-2"
```

```{r setup_colour_scales}
# lets set some custom colour scales for our plots using unikn
#seecol(pal_unikn_pair)
palette2 <- usecol(pal_unikn_pair) 
colours3 <- c("planning" = palette2[11],    
              "control" = palette2[10]          # planning control condition
              # "psychoed" = palette2[1],
              # "control" = palette2[2]         # psychoed congrol condition
              )
```

```{r setup_data_proc_functions}
## set-up some functions to help process the raw data
# function to calculate average time between  button presses 
process_bps <- function(x) {
  data_f_bps = x[["pressTimes"]]  # get list of press times for this trial
  x[["meanPressLag"]] <- mean(as.numeric(diff(data_f_bps)))  # get mean difference between presses, in ms
  x[["pressTimes"]] <- "see raw data" # remove raw data for now for df-ability
  return(x)
}

# function to read all task data files in input list from json to nice df
read_reweff_json <- function(file) {
  # read file from json into an R list:
  data_f <- rjson::fromJSON(file = file, simplify = TRUE)

  # select only trial data (numbered list items)
  data_f_task <- data_f[grepl("^task.*.[[:digit:]]", names(data_f))]
  
  # process press times for all trials for this participant:
  data_f_task_proc <- lapply(data_f_task, process_bps) 
  # convert to tibble to easily un-nesting of list data
  data_tib <- tibble(data_f_task_proc)  %>% 
    unnest_wider(data_f_task_proc)
  
  # and finally convert to a df with all the other info we want:
  data_df <- as.data.frame(data_tib) %>%
    arrange(trialNo) %>%
    mutate(subID = data_f$prolificSubID,
           studyID = data_f$prolificStudyID,
           firebaseID = data_f$firebaseUID,
           taskVer = task_ver,
           studyStartTime = sub(".*\\s+", "", strptime(data_f$consentTime, "%H:%M:%S"))) 
}

# function to read all files in input list from json to nice df
read_posttask_json_ratings <- function(file) {
  # read file from json into an R list:
  data_f <- rjson::fromJSON(file = file, simplify = TRUE)
  # select only trial data (numbered list items)
  data_f2 <- data_f[lengths(data_f)>1]
  data_f_quest <- data_f2[grepl("[[:digit:]]", names(data_f2))]

  # convert to tibble to easily un-nesting of list data
  data_tib <- tibble(data_f_quest)  %>% 
    unnest_wider(data_f_quest)
  
  # and finally convert to a df with all the other info we want:
  data_df <- as.data.frame(data_tib) %>%
    arrange(questionNo) %>%
    mutate(subID = data_f$prolificSubID)
}

# function to read all files in input list from json to nice df
read_posttask_json_phq <- function(file) {
  # read file from json into an R list:
  data_f <- rjson::fromJSON(file = file, simplify = TRUE)
  # select only trial data (numbered list items)
  data_f <- data_f[lengths(data_f)<2]
  data_f_quest <- data_f[grepl("[[:digit:]]", names(data_f))]
  
  # and finally convert to a df with all the other info we want:
  data_df <- as.data.frame(data_f_quest) %>%
    mutate(subID = data_f$prolificSubID) %>%
    melt(id.var = "subID") %>%
    separate(variable, into=c("time", "question"), sep=9) %>%
    arrange(time, question)
}

# function to read all files in input list from json to nice df
read_quest_json <- function(file) {
  # read file from json into an R list:
  data_f <- rjson::fromJSON(file = file, simplify = TRUE)
  # select only trial data (numbered list items)
  data_f_quest <- data_f[lengths(data_f)>1]
  
  # convert to tibble to easily un-nesting of list data
  data_tib <- tibble(data_f_quest) %>%
    unnest_longer(data_f_quest)
  
  # and finally convert to a df with all the other info we want:
  data_df <- as.data.frame(data_tib) %>%
    rename("answer" = "data_f_quest",
           "quest" = "data_f_quest_id") %>%
    mutate(subID = data_f$prolificSubID)
}

read_misc_json <- function(file) {
  # read file from json into an R list:
  data_f <- rjson::fromJSON(file = file, simplify = TRUE)
  # select only trial data (numbered list items)
  data_f_misc <- data_f[grepl("block", names(data_f))]
  
  # and finally convert to a df with all the other info we want:
  data_df <- as.data.frame(data_f_misc) %>%
    mutate(subID = data_f$prolificSubID,
           interventionQuizAnswer = data_f$interventionQuizAnswer,
           interventionReadingTime = data_f$interventionQuizCompleteTime/60000) %>%
    rename_at(vars(contains('goal')), funs(sub('goal', 'answer', .)))
}
```

```{r load_data}
# # load all the existing data files
# # get list of individual ppt files (main task data files only)
# data_files <- list.files(path = data_dir,
#                          pattern = paste0("^", task_ver, ".*data.txt$"),
#                          full.names = TRUE)
# data_files <- data_files[!grepl("5c4f30828f1259000172240d", data_files) & # didn't finish
#                            !grepl("5eadaf4eb6da4d086ffdb3ba", data_files)] # only did 3 mins
# 
# # apply preproc functions to get the data in a nice df format
# data_all <- lapply(data_files, read_reweff_json)   # returns nested list of processed data
# data_long <- do.call(rbind, data_all)              # binds all list elements into one big df

# OR load pre-processed csv
data_long <- read.csv(file=paste0(task_ver, "-task-data-long.csv"))
```

```{r get_ppts_trials}
## get the number of participants and number of trials per participant in the current dataset
nPpts <- length(unique(data_long$subID))  # get number of participants
nTrials_all <- data_long %>%              # get number of trials each participant actually completed
  group_by(subID) %>%
  summarize(nTrials = n()) %>%
  mutate(ID=seq(1, nPpts, 1))             # assign sequential numeric subIDs for ease / anonymity

#data_long <- merge(data_long, nTrials_all, by="subID")

# maximum number of trials 
nTrials_max <- nTrials_all %>%
  {max(.$nTrials)}

# define list of subs in each group for easy use with other data
control_subs <- data_long %>%
  filter(condition=="control") %>%
  dplyr::select(subID)
controls <- as.list(unique(control_subs$subID))

active_subs <- data_long %>%
  filter(condition=="planning") %>%
  dplyr::select(subID)
planners <- as.list(unique(active_subs$subID))
```

Participants so far for task version `r task_ver` (*N*=`r nPpts`):

```{r prolific_QC_bonus}
# get basic quality control data and determine profilic bonuses
QC_bonus <- data_long %>%              
  group_by(subID, condition) %>%
  arrange(studyStartTime) %>%
  summarize(nTrials = n(),
            timeOnTask = round((trialStartTime[nTrials]-trialStartTime[1])/60000, 1),
            #totalStudyTime = totalStudyTime[1],
            failedTrials = sum(trialSuccess==0), 
            nonAttempts = sum(pressCount==0),
            prop1 = round(sum(choice=="route 1")/(nTrials[1]), 2),
            catchCorrect = as.integer(choice[15]=="route 2") + as.integer(choice[28]=="route 1"),
            totalCoins = sum(coinsRunningTotal[11] +
                             coinsRunningTotal[22] +
                             coinsRunningTotal[33] +
                             coinsRunningTotal[44]),
            bonusGBP = round(totalCoins*0.002,2),
            maxPressCount = round(trialEffort1[1]/trialEffortPropMax1[1]),
            studyID = studyID[1]
  )
knitr::kable(QC_bonus,
             caption = paste(task_ver, "task data"))

# N's per cond
N_cond <- QC_bonus %>%
  group_by(condition) %>%
  summarise(N=n())
knitr::kable(N_cond)

# # export list of prolific IDs and bonuses in {key: value} format for batch bonusing:
# bonus <- QC_bonus %>%
#   select(subID, studyID, bonusGBP) %>%
#   arrange(studyID, subID) %>%
#   group_by(subID) %>%
#   summarise(bonus = sum(bonusGBP)) %>%
#   apply(., 1, function(x){cat(x, sep = ','); cat("\n")})
```

### Overall QC

```{r qc_plots}
qc_p <- QC_bonus %>%
  ungroup() %>%
  mutate(group = ifelse(subID %in% controls, "control", "planning")) %>%
  mutate(propTrialsCompleted = nTrials/(nTrials_max/2),
         propCatchCorrect = catchCorrect/2,
         propNonAttempts = nonAttempts/(nTrials_max/2),
         propFailedTrials = failedTrials/(nTrials_max/2),
         propCoinsCollected = totalCoins/266) %>%
  melt(id.vars=c("group")) %>%
  filter(variable == "propTrialsCompleted" | variable == "propCatchCorrect" |
         variable == "propNonAttempts" | variable == "propFailedTrials") %>%
  group_by(group, variable) %>%
  summarise(mean = mean(as.numeric(value), na.rm=TRUE),
            sd = sd(value)) %>%
  ggplot(aes(x=variable, y=mean, fill=group, group=group)) +
  geom_bar(stat="Identity", position=position_dodge2(0.8)) +
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), position = position_dodge2(width=0.4, padding=0.4)) +
  theme_minimal() + ylim(-0.03,1.3) + ylab("") + 
  scale_fill_manual(values=wes_palette(n=4, name="Darjeeling1"))
qc_p
```

```{r basic_derivs}
# # ! don't need to run if loading pre-processed data, included for reference only
# # let's compute a few basic derived metrics which will be useful to look at
# data_long <- data_long %>%
#     mutate(deltaReward = as.factor(abs(trialReward1 - trialReward2)),
#            deltaEffort = as.factor(abs(round(trialEffortPropMax1 - trialEffortPropMax2,2))),
#            effortChosen = ifelse(choice=="route 1", trialEffortPropMax1, trialEffortPropMax2),
#            effortUnchosen = ifelse(choice=="route 1", trialEffortPropMax2, trialEffortPropMax1),
#            deltaEffortSigned = effortChosen - effortUnchosen,
#            higherEffChosen = as.integer((effortChosen > effortUnchosen)),
#            highEffortOption = pmax(effortChosen, effortUnchosen),
#            rewardChosen = ifelse(choice=="route 1", trialReward1, trialReward2),
#            rewardUnchosen = ifelse(choice=="route 1", trialReward2, trialReward1),
#            higherRewChosen = as.integer((rewardChosen > rewardUnchosen)),
#            highRewardOption = as.factor(pmax(rewardChosen, rewardUnchosen)),
#            taskNo = ifelse(condition=="baseline", 1, 2),
#            group = ifelse(subID %in% controls, "control", "planning")) %>%
#   group_by(subID, condition) %>%
#   mutate(maxPressCount = round(trialEffort1[1]/trialEffortPropMax1[1]))
# 
# # save a copy
# write.csv(data_long, file=paste0(task_ver, "-task-data-long.csv"))
```

### Visual QC: choice data

Let's plot out some simple measures to see how people are behaving on the task.

(The two 'catch' trials consisting of dominated gambles are not included in this data).


```{r followup}
# group plot
p1 <- data_long %>%
  ungroup() %>%
  mutate(deltaEffort = (abs(round(trialEffortPropMax1 - trialEffortPropMax2,2))),
         taskNo = as.factor(taskNo)) %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>%  # rm catch trials
  ggplot(aes(x=deltaEffort, y=higherEffChosen, group = taskNo, colour=taskNo, fill=taskNo)) +
  stat_summary(fun=mean, geom="line") +
  stat_summary(fun.data=mean_se, geom="ribbon", alpha=.2, colour = NA) +
  ylab("proportion higher effort/higher reward choices") +
  xlab("delta effort") + 
  theme_minimal() + theme(legend.position="top") + ylim(0,1) + 
  facet_grid(cols=vars(group))
p1

# group plot
p2 <- data_long %>%
  ungroup() %>%
  mutate(deltaReward = (abs(trialReward1 - trialReward2)),
         taskNo = as.factor(taskNo)) %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>%  # rm catch trials
  ggplot(aes(x=deltaReward, y=higherEffChosen, group = taskNo, colour=taskNo, fill=taskNo)) +
  stat_summary(fun=mean, geom="line") +
  stat_summary(fun.data=mean_se, geom="ribbon", alpha=.2, colour = NA) +
  ylab("") +
  xlab("delta reward") +
  theme_minimal() + theme(legend.position="top") + ylim(0,1) + 
  facet_grid(cols=vars(group))
p2

# group plot
p2 <- data_long %>%
  ungroup() %>%
  mutate(deltaReward = (abs(trialReward1 - trialReward2)),
         taskNo = as.factor(taskNo)) %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>%  # rm catch trials
  ggplot(aes(x=trialNo, y=higherEffChosen, group = taskNo, colour=taskNo, fill=taskNo)) +
  stat_summary_bin(fun=mean, geom="line", binwidth = 10) +
  stat_summary_bin(fun.data=mean_se, geom="ribbon", binwidth = 10, alpha=.2, colour = NA) +
  ylab("proportion higher effort/higher reward choices") +
  xlab("trial no (smoothed over 10 trial bins)") + 
  theme_minimal() + theme(legend.position="top") + ylim(0,1) + 
  facet_grid(cols=vars(group))
p2
```

```{r overall_stats}
# linear mixed model
lme1 <- lmer(higherEffChosen ~ group * taskNo + trialNo + ( 1 | subID ), data=data_long)
summary(lme1)
anova(lme1)
emmeans(lme1, list(pairwise ~ group*taskNo), adjust = "tukey", pbkrtest.limit = 8800) #
```

```{r other_stats}
# arrange data for rm anova by task N and group
data_aov <- data_long %>%
  group_by(subID, taskNo, group) %>%
  summarise(totalCoins = sum(rewardChosen),
            totalPresses = sum(pressCount)) %>%
  ungroup()

# plot
p <- data_aov %>%
  melt() %>%
  group_by(taskNo, group, variable) %>%
  summarise(mean = mean(as.numeric(value), na.rm=TRUE),
            sd = sd(value)) %>%
  ggplot(aes(x=taskNo, y=mean, fill=group, group=group)) +
  geom_bar(stat="Identity", position=position_dodge2(0.8)) +
  geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), position = position_dodge2(width=0.4, padding=0.4)) +
  theme_minimal() + #ylab("") + ylim(-0.03,1.3) +
  scale_fill_manual(values=wes_palette(n=4, name="Darjeeling1")) + 
  facet_wrap(~variable, scales="free")
p

# total reward earned
res.aov <- anova_test(data = data_aov, dv = totalCoins, wid = subID, within = taskNo,
                      between=group)
get_anova_table(res.aov)
# pairwise
pwc <- data_aov %>%
  group_by(group) %>%
  pairwise_t_test(totalCoins ~ taskNo, p.adjust.method = "bonferroni", paired=TRUE)
pwc

# total presses made
res.aov <- anova_test(data = data_aov, dv = totalPresses, wid = subID, within = taskNo,
                      between=group)
get_anova_table(res.aov)
# pairwise
pwc <- data_aov %>%
  group_by(group) %>%
  pairwise_t_test(totalPresses ~ taskNo, p.adjust.method = "bonferroni", paired=TRUE)
pwc
```

```{r followup2}
a_b <- data_long %>%
  ungroup() %>%
  filter(condition == "baseline") %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>%  # rm catch trials
  mutate(lowerEffValue = as.factor(pmin(trialEffortPropMax1,trialEffortPropMax2)),
         higherEffValue = as.factor(pmax(trialEffortPropMax1,trialEffortPropMax2))) %>%
  group_by(lowerEffValue, higherEffValue) %>%
  summarise(meanHigherEff = mean(higherEffChosen)) %>%
  ggplot(aes(x=lowerEffValue, y=higherEffValue)) +
  geom_bin2d(bins = 5, aes(fill=meanHigherEff)) + 
  scale_fill_gradientn(limits = c(0,1), colours=c("navyblue", "skyblue")) +
  theme_minimal()
a_b

a_c <- data_long %>%
  ungroup() %>%
  filter(condition == "control") %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>%  # rm catch trials
  mutate(lowerEffValue = as.factor(pmin(trialEffortPropMax1,trialEffortPropMax2)),
         higherEffValue = as.factor(pmax(trialEffortPropMax1,trialEffortPropMax2))) %>%
  group_by(lowerEffValue, higherEffValue) %>%
  summarise(meanHigherEff = mean(higherEffChosen)) %>%
  ggplot(aes(x=lowerEffValue, y=higherEffValue)) +
  geom_bin2d(bins = 5, aes(fill=meanHigherEff)) + 
  scale_fill_gradientn(limits = c(0,1), colours=c("navyblue", "skyblue")) +
  theme_minimal()
a_c

a_p <- data_long %>%
  ungroup() %>%
  filter(condition == "planning") %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>%  # rm catch trials
  mutate(lowerEffValue = as.factor(pmin(trialEffortPropMax1,trialEffortPropMax2)),
         higherEffValue = as.factor(pmax(trialEffortPropMax1,trialEffortPropMax2))) %>%
  group_by(lowerEffValue, higherEffValue) %>%
  summarise(meanHigherEff = mean(higherEffChosen)) %>%
  ggplot(aes(x=lowerEffValue, y=higherEffValue)) +
  geom_bin2d(bins = 5, aes(fill=meanHigherEff)) + 
  scale_fill_gradientn(limits = c(0,1), colours=c("navyblue", "skyblue")) +
  theme_minimal()
a_p
```

We can also plot proportion of high effort options chosen over the whole task as a function of the difference in effort and difference in reward between options.


```{r sanity_check1}
# plot of difference proportionate choice of the higher effort option as a function of 
# difference in effort and reward between the choice options
# (can just use absolute difference values as higher effort is always higher reward except catch trials)
p <- data_long %>%
  mutate(deltaEffort = (abs(round(trialEffortPropMax1 - trialEffortPropMax2,2))),
         deltaEffortB = ifelse(deltaEffort<=0.2,"0.15-0.2",
                               ifelse(deltaEffort<=0.4, "0.35-0.4",
                                      ifelse(deltaEffort<=0.6, "0.6", "0.75")))) %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>% 
  filter(!(deltaEffort==0.4 & deltaReward == 2)) %>%
  ggplot(aes(x=deltaEffortB, y=higherEffChosen, colour=deltaReward, group=deltaReward)) +
  stat_summary(fun=mean, geom="line") +
  stat_summary(fun.data=mean_se, geom="ribbon", aes(fill=deltaReward), alpha=.2, colour = NA) +
  ylab("proportion higher effort/higher reward choices") + ylim(0,1) +
  theme_minimal() + theme(legend.position="top") + 
  facet_grid(cols = vars(taskNo), rows = vars(group))
p
```

We can quickly look if it seems like participants are choosing based on option number, rather than choice details, by plotting proportion of choice 1 over the course of the task.


```{r sanity_check8}
# proportion right option choices
p <- data_long %>%
  mutate(prop1 = as.integer((choice == "route 1"))) %>%
  ggplot(aes(x=trialNo, y=prop1)) +
  stat_summary_bin(fun=mean, geom="line", binwidth=11) +
  stat_summary_bin(fun.data=mean_se, geom="ribbon", alpha=.2, colour = NA,
                   binwidth=11) +
  theme_minimal() + ylim(0,1) + theme(legend.position="none") + ylab("proportion option 1 chosen")
p
```

### Effects of participant-level effort calibration

Let's see if the objective level of effort participants have to undertake on each trial is related to their choice of the higher effort option. Since this might be affected by fatigue, let's look separately for each block of the task.


```{r sanity_check3}
# does proportion of high effort responses correlate with objective effort
p <- data_long %>%
  group_by(subID, taskNo, group) %>%
  summarise(propHigherEff = mean(higherEffChosen),
            maxPressCount = maxPressCount[1]) %>%
  ungroup() %>%
  ggplot(aes(x=maxPressCount, y=propHigherEff, colour=subID)) +
  geom_point() + 
  geom_smooth(method = "lm", se=TRUE, alpha=.2, color="grey", formula = y~x) +
  theme_minimal() + ylim(0,1) + theme(legend.position="none") +
  facet_grid(rows=vars(group), cols=vars(taskNo))
p
  
# and by block
p <- data_long %>%
  mutate(block = ifelse(trialNo<=10, 'block 1', 
                        ifelse(trialNo<=21, 'block 2', 
                               ifelse(trialNo<=33, 'block 3', 
                                      'block 4')))) %>%
  group_by(subID, block) %>%
  summarise(propHigherEff = mean(higherEffChosen),
            maxPressCount = maxPressCount[1]) %>%
  ungroup() %>%
  ggplot(aes(x=maxPressCount, y=propHigherEff, colour=subID)) +
  geom_point() + 
  geom_smooth(method = "lm", se=TRUE, alpha=.2, color="grey", formula = y~x) +
  theme_minimal() + ylim(0,1) + theme(legend.position="none") + 
  xlab("max press count (as measured during pre-task calibration)") + 
  ylab("proportion higher effort choices") +
  facet_wrap(~block)
p
```

We can also see how actual effort expended (number of presses) relates to the required effort for each trial, and if this varies by participant and calibration press count.

(Here, anything above the line y=x is additional effort, anything below this line would represent a failed trial, and any recorded press counts of 0 would represent non-attempts)


```{r sanity_check4}
p <- data_long %>%
  mutate(effortChosenActual = ifelse(choice=="route 1", trialEffort1, trialEffort2)) %>%
  ggplot(aes(x=effortChosenActual, y=pressCount, colour=subID)) +
  geom_point() + 
  geom_abline(slope = 1, linetype="dashed", colour="grey") +
  theme_minimal()  + theme(legend.position="none") +
  xlab("required effort") + ylab("actual press count") +
  facet_grid(rows=vars(group), cols=vars(taskNo))
p

# arrange data for rm anova by task N and group
data_aov <- data_long %>%
  group_by(subID, taskNo, group) %>%
  summarise(totalFailed = sum(trialSuccess==0)) %>%
  ungroup()

# total failed trials
res.aov <- anova_test(data = data_aov, dv = totalFailed, wid = subID, within = taskNo,
                      between=group)
get_anova_table(res.aov)
# pairwise
pwc <- data_aov %>%
  group_by(group) %>%
  pairwise_t_test(totalFailed ~ taskNo, p.adjust.method = "bonferroni", paired=TRUE)
pwc
pwc <- data_aov %>%
  group_by(taskNo) %>%
  pairwise_t_test(totalFailed ~ group, p.adjust.method = "bonferroni")
pwc
```

### Effects of free choice time

Since we are not imposing any constraints / limits on the time participants can take to choose between options, they may be using this time to rest between trials or do something else (NB Prolific will time-out participants after a limit of 2.5* estimated study time is reached). 

There are 3 points during the task where participants were invited to take a break if they wanted to (between each of the 4 blocks of 11 trials).


```{r sanity_check5}
p <- data_long %>%
  group_by(subID, taskNo) %>%
  mutate(trialStartTimeRel = (trialStartTime - trialStartTime[1])/60000) %>%
  ggplot(aes(x=trialStartTimeRel, y=ID, colour=interaction(subID,taskNo))) +
  geom_point() + ylab("participant") + xlab("trial onset times (mins)") +
  theme_minimal() + theme(legend.position="none") + scale_y_reverse() + xlim(0,90) +
  facet_wrap(~group)
p

data_aov <- data_long %>%
  group_by(subID, taskNo, group) %>%
  summarise(medianTrialTime = median(diff(trialStartTime))/6000) %>%
  ungroup
res.aov <- anova_test(data = data_aov, dv = medianTrialTime, wid = subID, within = c(taskNo), 
                      between=group)
get_anova_table(res.aov)
```

### Visual QC: choice RT and response vigour data

Choice RT data over the course of the task (too fast times might represent inattentive responding, too slow times might suggest the participant is finding the effort exertion too strenuous or doing something else at the same time).


```{r sanity_check6}
# median choice RTs over task
# group level plot:
p1 <- data_long %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>%  # rm catch trials
  mutate(choiceRTsec = choiceRT/1000) %>%
  ggplot(aes(x=trialNo, y=choiceRTsec, group=taskNo, colour=taskNo, fill=taskNo)) +
  stat_summary_bin(fun=mean, geom="line", binwidth=11) +
  stat_summary_bin(fun.data=mean_se, geom="ribbon", alpha=.2, colour = NA,
                   binwidth=11) +
  theme_minimal() + theme(legend.position="top") + 
  ylab("mean choice RT (s)") +
  xlab("trial (smoothed over 11 trial block bins)") + 
  facet_grid(cols =vars(group))
p1

p2 <- data_long %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>%  # rm catch trials
  mutate(choiceRTsec = choiceRT/1000) %>%
  ggplot(aes(x=trialNo, y=choiceRTsec, group=taskNo, fill=taskNo, colour=taskNo)) +
  stat_summary_bin(fun=median, geom="line", binwidth=11, ) +
  stat_summary_bin(fun.min = function(z) { quantile(z,0.25) },
                   fun.max = function(z) { quantile(z,0.75) }, 
                   geom="ribbon", alpha=.2, colour = NA,
                   binwidth=11) +
  theme_minimal() + theme(legend.position="top") + 
  ylab("median choice RT (s)") +
  xlab("trial (smoothed over 11 trial block bins)") + 
  facet_grid(cols =vars(group))
p2

# linear mixed model
lme1 <- lmer(choiceRT ~ group * taskNo * trialNo + ( 1 | subID ), data=data_long)
summary(lme1)
anova(lme1)
emmeans(lme1, list(pairwise ~ group*taskNo), adjust = "tukey") #, pbkrtest.limit = 8800
```

We can also look at the mean time between button presses, to see if participants are tending to either speed up (shorter lag times) or slow down (longer lag times) with time on task.

```{r sanity_check7}
# mean lag times over task
p1 <- data_long %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>%  # rm catch trials
  mutate(meanPressRate = 1/(meanPressLag/1000),
         taskNo = as.factor(taskNo)) %>%
  ggplot(aes(x=trialNo, y=meanPressRate, group=taskNo, colour=taskNo, fill=taskNo)) +
  stat_summary_bin(fun=mean, geom="line", binwidth=11) +
  stat_summary_bin(fun.data=mean_se, geom="ribbon", alpha=.2, colour = NA,
                   binwidth=11) +
  theme_minimal() + theme(legend.position="top") + 
  ylab("mean press rate (Hz)") +
  xlab("trial (smoothed over 11 trial block bins)") + 
  facet_grid(cols =vars(group))
p1

p2 <- data_long %>%
  filter(!(trialReward1==8 | trialReward2 ==8)) %>%  # rm catch trials
  mutate(pressRate = 1/(meanPressLag/1000),
         taskNo = as.factor(taskNo)) %>%
  ggplot(aes(x=trialNo, y=pressRate, group=taskNo, colour=taskNo, fill=taskNo)) +
  stat_summary_bin(fun=median, geom="line", binwidth=11, ) +
  stat_summary_bin(fun.min = function(z) { quantile(z,0.25) },
                   fun.max = function(z) { quantile(z,0.75) }, 
                   geom="ribbon", alpha=.2, colour = NA,
                   binwidth=11) +
  theme_minimal() + theme(legend.position="top") + 
  ylab("median press rate (Hz)") +
  xlab("trial (smoothed over 11 trial block bins)") + 
  facet_grid(cols =vars(group))
p2

# linear mixed model
data_long <- data_long %>%
  mutate(pressRate = (1/(meanPressLag/1000)))
lme1 <- lmer(pressRate ~ group * taskNo * trialNo + ( 1 | subID ), data=data_long)
summary(lme1)
anova(lme1)
equatiomatic::extract_eq(lme1, wrap = TRUE, terms_per_line = 3)
emmeans(lme1, list(pairwise ~ group*taskNo), adjust = "tukey") #, pbkrtest.limit = 8800
```

### Post-task ratings data

Finally, we can inspect the post-task ratings data, which asked participants:

  1. During the task, did you feel A SENSE OF ACHIEVEMENT when you collected the coins?

  2. During the task, did you feel PLEASED when you collected the coins?

  3. During the task, did you feel BORED?


```{r load_posttask}
# # get list of individual ppt files (main task data files only)
# post_data_files <- list.files(path = data_dir, 
#                          pattern = paste0("^", task_ver, ".*post-task-ratings.txt$"),
#                          full.names = TRUE)
# 
# # apply preproc functions to get the data in a nice df format
# data_post_ratings_all <- lapply(post_data_files, read_posttask_json_ratings)   # returns nested list of processed data
# data_post_ratings_long <- do.call(rbind, data_post_ratings_all)                # binds all list elements into one big df
# 
# # save a copy
# write.csv(data_post_ratings_long, file=paste0(task_ver, "-post-task-data-long.csv"))
data_post_ratings_long <- read.csv(file=paste0(task_ver, "-post-task-data-long.csv")) %>%
  dplyr::select(-X) %>%
  mutate(taskNo = taskN)
```

```{r sanity_posttask}
# post-block pleasure and achievement ratings
r1 <- data_post_ratings_long %>%
  filter(questionNo==1 | questionNo==2) %>%
  mutate(condition = ifelse((subID %in% controls), "control", "planning"),
         question = ifelse((questionNo==1), "pleased with reward", 
                           "sense of achievement from sucessful effort"),
         postTask = ifelse((taskNo==0), "post task 1", "post task 2")) %>%
  ggplot(aes(x=questionStage, y=answer, group=interaction(question,questionStage), 
             fill=question, colour=question)) +
       geom_flat_violin(position=position_nudge(x = .1, y = 0),  
                        adjust = 1.5, trim = TRUE, alpha = .4, colour = NA) +
       geom_point(position=position_jitter(width=.02), size = 3, shape = 20) +
       geom_line(aes(group=subID), colour="grey", alpha = .4) +
       geom_boxplot(outlier.shape = NA, alpha = .5, width = .3, colour = "black") +
       theme_minimal() + ylim(0,100) +
       labs(x="", y="rating (0-100)") +
       theme(legend.title = element_blank()) + theme(legend.position="top")
r1p <- r1 + facet_grid(rows=vars(condition), cols=vars(postTask))
r1p

# post-block boredom ratings
r1 <- data_post_ratings_long %>%
  filter(questionNo==3) %>%
  mutate(condition = ifelse((subID %in% controls), "control", "planning"),
         question = ifelse((questionNo==3), "boredom", ""),
         postTask = ifelse((taskNo==0), "post task 1", "post task 2")) %>%
  ggplot(aes(x=questionStage, y=answer, group=interaction(question,questionStage),
             fill=question, colour=question)) +
       geom_flat_violin(position=position_nudge(x = .1, y = 0),  
                        adjust = 1.5, trim = TRUE, alpha = .4, colour = NA) +
       geom_point(position=position_jitter(width=.02), size = 3, shape = 20) +
       geom_line(aes(group=subID), colour="grey", alpha = .4) +
       geom_boxplot(outlier.shape = NA, alpha = .5, width = .3, colour = "black") +
       theme_minimal() + ylim(0,100) +
       labs(x="", y="rating (0-100)") +
       theme(legend.title = element_blank()) + theme(legend.position="top")
r1b <- r1 + facet_grid(rows=vars(condition), cols=vars(postTask))
r1b

# pleased ratings data
data_post_long_1 <- data_post_ratings_long %>%
  mutate(condition = ifelse((subID %in% controls), "control", "planning"),
         postTask = ifelse((taskNo==0), "post task 1", "post task 2")) %>%
  filter(questionNo==1)
lme1 <- lmer(answer ~ condition * postTask * questionStage + ( 1 | subID ), data=data_post_long_1)
anova(lme1)
emmeans(lme1, list(pairwise ~ condition*postTask), adjust = "tukey") #, pbkrtest.limit = 8800

# achievement ratings data
data_post_long_2 <- data_post_ratings_long %>%
  mutate(condition = ifelse((subID %in% controls), "control", "planning"),
         postTask = ifelse((taskNo==0), "post task 1", "post task 2")) %>%
  filter(questionNo==2)
lme2 <- lmer(answer ~ condition * postTask * questionStage + ( 1 | subID ), data=data_post_long_2)
anova(lme2)
emmeans(lme2, list(pairwise ~ condition*postTask), adjust = "tukey") #, pbkrtest.limit = 8800

# boredom ratings data
data_post_long_3 <- data_post_ratings_long %>%
  mutate(condition = ifelse((subID %in% controls), "control", "planning"),
         postTask = ifelse((taskNo==0), "post task 1", "post task 2")) %>%
  filter(questionNo==3)
lme3 <- lmer(answer ~ condition * postTask * questionStage + ( 1 | subID ), data=data_post_long_3)
anova(lme3)
emmeans(lme3, list(pairwise ~ condition*postTask), adjust = "tukey") #, pbkrtest.limit = 8800
```


```{r load_selfreports}
# # get list of individual ppt files (main task data files only)
# quest_data_files <- list.files(path = data_dir, 
#                          pattern = paste0("^", task_ver, ".*-self-reports.txt$"),
#                          full.names = TRUE)
# 
# # apply preproc functions to get the data in a nice df format
# data_quest_all <- lapply(quest_data_files, read_quest_json)   # returns nested list of processed data
# data_quest_long <- do.call(rbind, data_quest_all)             # binds all list elements into one big df
# data_quest_wide <- pivot_wider(data_quest_long, id_cols = subID, names_from = quest, values_from = answer) %>%
#   select(-P0_Q0, -study_feedback, -P0_Q7) %>%
#   # fix list data identified using sapply(data_quest_wide, class) so can save as csv
#   mutate(across(c(is.list, -contains("demogs"), -contains("acceptability")), 
#                 as.numeric),
#          demogs_age = as.numeric(demogs_age),
#          across(c(is.list),
#                 as.character)) 

# # save a copy
# write.csv(data_quest_wide, file=paste0(task_ver, "-self-report-data.csv"))

# OR load pre-processed data
data_quest_wide <- read.csv(file=paste0(task_ver, "-self-report-data.csv")) %>%
  dplyr::select(-X)
```

```{r table_demogs}
# create a demographic summary table
summ <- data_quest_wide %>%
  mutate(prevPsychTx = ifelse(grepl("yes", demogs_tx), "yes", 
                              ifelse(demogs_tx=="prefer not to say", "prefer not to say", "no")),
         tx_talkingTher = ifelse(grepl("talking therapy", demogs_tx), "yes", "no"),
         tx_meds = ifelse(grepl("medication", demogs_tx), "yes", "no"),
         tx_selfGuided = ifelse(grepl("self-guided", demogs_tx), "yes", "no"),
         tx_other = ifelse(grepl("other", demogs_tx), "yes", "no")) %>%
  dplyr::select(demogs_age,
                demogs_gender,
                demogs_employment,
                demogs_financial,
                demogs_housing,
                demogs_neurodiv,
                prevPsychTx,
                tx_talkingTher,
                tx_meds,
                tx_selfGuided,
                tx_other,
                PHQ9_total,
                AMI_behavActiv,
                miniSPIN_total)

view(dfSummary(summ))
```


```{r plot_demogs}
p1 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=demogs_age, fill=group, group=group)) +
  geom_histogram(alpha=.6, position = "identity") + 
  theme_minimal() + theme(legend.position = "none") +
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  xlab("age")

p2 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=demogs_gender, fill=group, group=group)) +
  geom_bar(aes(y=..prop..), alpha=.6, position = "dodge") + 
  theme_minimal() + theme(legend.position = "none") + theme(axis.text.x = element_text(angle = 45, vjust=1.1, hjust=1)) +
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  xlab("gender identity")


p3 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=demogs_housing, fill=group, group=group)) +
  geom_bar(aes(y=..prop..), alpha=.6, position = "dodge") + 
  scale_x_discrete(labels=c("homeowner", "tenant", "other")) +
  theme_minimal() + theme(legend.position = "none") + theme(axis.text.x = element_text(angle = 45, vjust=1.1, hjust=1)) +
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  xlab("housing status")

p4 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=demogs_employment, fill=group, group=group)) +
  geom_bar(aes(y=..prop..), alpha=.6, position = "dodge") + 
  scale_x_discrete(labels=c("employed", "not seeking", "unemployed")) +
  theme_minimal() + theme(legend.position = "none") + theme(axis.text.x = element_text(angle = 45, vjust=1.1, hjust=1)) +
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  xlab("employment status")

p5 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=demogs_financial, fill=group, group=group)) +
  geom_bar(aes(y=..prop..), alpha=.6, position = "dodge") + 
  scale_x_discrete(labels=c("doing OK", "just getting by", "struggling")) +
  theme_minimal() + theme(legend.position = "none") + theme(axis.text.x = element_text(angle = 45, vjust=1.1, hjust=1)) +
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  xlab("financial status")

p6 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=study_acceptability, fill=group, group=group)) +
  geom_bar(aes(y=..prop..), alpha=.6, position = "dodge") + 
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  theme_minimal() + xlab("task acceptability")

((p1 + p2 + p3) / (p4 + p5 + p6))

p7 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=demogs_neurodiv, fill=group, group=group)) +
  geom_bar(aes(y=..prop..), alpha=.6, position = "dodge") + 
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  theme_minimal() + xlab("self-reported neurodiversity") + theme(legend.position="none")

p8 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning"),
         prevPsychTx = ifelse(grepl("yes", demogs_tx), "yes", 
                              ifelse(demogs_tx=="prefer not to say", "prefer not to say", "no"))) %>%
  ggplot(aes(x=prevPsychTx, fill=group, group=group)) +
  geom_bar(aes(y=..prop..), alpha=.6, position = "dodge") + 
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  theme_minimal() + xlab("previous tx for a mental health problem")

(p7 + p8)

p9 <- data_quest_wide %>%
  mutate(condition = ifelse((subID %in% controls), "control", "planning"),
         tx_talkingTher = ifelse(grepl("talking therapy", demogs_tx), "yes", "no"),
         tx_meds = ifelse(grepl("medication", demogs_tx), "yes", "no"),
         tx_selfGuided = ifelse(grepl("self-guided", demogs_tx), "yes", "no"),
         tx_other = ifelse(grepl("other", demogs_tx), "yes", "no")) %>%
  select(subID, condition, contains("tx"), -demogs_tx) %>%
  melt(id.vars=c("subID", "condition")) %>%
  ggplot(aes(x=variable, fill=value, group=interaction(variable, value))) +
  geom_bar(alpha=.6, position = "dodge") + 
  theme_minimal() + xlab("") +
  scale_x_discrete(labels=c("talking therapy", "medication", "self-guided", "other"))
p9 <- p9 + facet_wrap(~condition)
p9
```


```{r score_selfreports}
# # ! don't need to re-run this code if loading pre-processed data, included only for reference
# # catch questions (both should==0/1)
# catchQs <- data_quest_wide[, grep(pattern ='catch', names(data_quest_wide))]
# data_quest_wide$catchQsCorrect <- ifelse(rowSums(catchQs[1:2])<2, "yes", "no")
# tmp <- data_quest_wide %>%
#   dplyr::select(subID, catchQsCorrect) %>%
#   filter(catchQsCorrect=="no")
#   
# # PHQ9
# PHQ9 <- data_quest_wide[, grep(pattern ='^PHQ9_.*', names(data_quest_wide))]  %>%
#   select(sort(tidyselect::peek_vars()))  # rearrange to alphabetical/numeric order
# data_quest_wide$PHQ9_total <- rowSums(PHQ9[1:9])
# 
# # SHAPS
# SHAPS <- data_quest_wide[, grep(pattern ='^SHAPS_.*', names(data_quest_wide))]  %>%
#   select(sort(tidyselect::peek_vars())) %>% 
#   relocate(c(SHAPS_10, SHAPS_11, SHAPS_12, SHAPS_13, SHAPS_14), .after = last_col()) %>%
#   mutate(across(is.numeric,
#                ~recode(., `0`=1,`1`=1,`2`=0,`3`=0))) # any disagree = 1 and any agree = 0
# data_quest_wide$SHAPS_total <- rowSums(SHAPS)
# 
# # AMI
# AMI <- data_quest_wide[, grep(pattern ='^AMI_.*', names(data_quest_wide))]  %>%
#   select(sort(tidyselect::peek_vars())) %>% 
#   relocate(c(AMI_10, AMI_11, AMI_12, AMI_13, AMI_14, AMI_15, AMI_16, AMI_17, AMI_18), .after = last_col()) %>%
#   mutate(across(is.numeric,
#                ~recode(., `0`=4,`1`=3,`2`=2,`3`=1, `4`=0))) # all items reverse coded (higher score = greater apathy)
# data_quest_wide$AMI_behavActiv <- rowMeans(AMI[c(5,9,10,11,12,15)]) # tendency to self-initiate goal-directed behaviour 
# data_quest_wide$AMI_socialMotiv <- rowMeans(AMI[c(2,3,4,8,14,17)])  # level of engagement in social interactions
# data_quest_wide$AMI_emoSens <- rowMeans(AMI[c(1,6,7,13,16,18)])     # feelings of positive and negative affection
# 
# # miniSPIN
# miniSPIN <- data_quest_wide[, grep(pattern ='^miniSPIN_.*', names(data_quest_wide))]  %>%
#   select(sort(tidyselect::peek_vars()))
# data_quest_wide$miniSPIN_total <- rowSums(miniSPIN)
#
# # save a copy
# write.csv(data_quest_wide, file=paste0(task_ver, "-self-report-data.csv"))
```

```{r plot_selfreports}
# self-reported psychological symptoms
p1 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=PHQ9_total, fill=group, group=group)) +
  geom_histogram(alpha=.6, position = "identity") + 
  theme_minimal() + theme(legend.position = "none") +
  geom_vline(xintercept = 10, linetype = "dashed") +  # rough cutoff for clinical depression
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  xlab("PHQ9 total")

p3 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=AMI_behavActiv, fill=group, group=group)) +
  geom_histogram(alpha=.6, position = "identity") + 
  theme_minimal() + theme(legend.position = "none") +
  geom_vline(xintercept = 2.34, linetype = "dashed") +  # rough cutoff for moderate apathy
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  xlab("AMI: behavioural")

p4 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=AMI_socialMotiv, fill=group, group=group)) +
  geom_histogram(alpha=.6, position = "identity") + 
  theme_minimal() + theme(legend.position = "none") +
  geom_vline(xintercept = 2.43, linetype = "dashed") +  # rough cutoff for moderate apathy
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  xlab("AMI: social")

p5 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=AMI_emoSens, fill=group, group=group)) +
  geom_histogram(alpha=.6, position = "identity") + #, binwidth=5
  theme_minimal() + theme(legend.position = "none") +
  geom_vline(xintercept = 1.68, linetype = "dashed") +  # rough cutoff for moderate apathy
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  xlab("AMI: emotional")

p6 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=miniSPIN_total, fill=group, group=group)) +
  geom_histogram(alpha=.6, position = "identity") + #, binwidth=5
  theme_minimal() + theme(legend.position = "none") +
  geom_vline(xintercept = 6, linetype = "dashed") +  # rough cutoff for moderate apathy
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  xlab("miniSPIN total")

((p1 + p2 + p3) / (p4 + p5 + p6))

# catch questions
p0 <- data_quest_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=catchQsCorrect, fill=group, group=group)) +
  geom_bar(aes(y=..prop..), alpha=.6, position = "dodge") + 
  theme_minimal() + xlab("catch questions correct?")
p0
```

```{r plot_misc}
# # apply preproc functions to get the data in a nice df format
# misc_data_all <- lapply(data_files, read_misc_json)   # returns nested list of processed data
# misc_data_wide <- do.call(rbind, misc_data_all)
# # save a copy
# write.csv(misc_data_wide, file=paste0(task_ver, "-misc-data.csv"))

# # OR, load data
misc_data_wide <- read.csv(file=paste0(task_ver, "-misc-data.csv")) %>%
  dplyr::select(-X)

# intervention quiz correct and time spent
p0 <- misc_data_wide %>%
  mutate(intQuizCorrect = ifelse(interventionQuizAnswer=="C", "yes", "no"),
         group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=intQuizCorrect, fill=group, group=group)) +
  geom_bar(aes(y=..prop..), alpha=.6, position = "dodge") + 
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  theme_minimal() + theme(legend.position = "none") + xlab("intervention quiz correct?")

p0b <- misc_data_wide %>%
  mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  ggplot(aes(x=interventionReadingTime, fill=group, group=group)) +
  geom_histogram(alpha=.6, position = "identity") + #, binwidth=5
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  theme_minimal() + xlab("intervention reading time (s)")

(p0 + p0b)

# block goals
p1 <- misc_data_wide %>%
  filter(subID %in% planners) %>%
  select(-interventionQuizAnswer, -interventionReadingTime) %>%
  melt(id.col="subID") %>%
  arrange(variable) %>%
  mutate(variable = factor(variable, 
                           levels=c("block0answer", "block1answer", "block2answer", "block3answer"))) %>%
  ggplot(aes(x=variable, y=value, group=subID, fill=subID, colour=subID)) +
  geom_point() +
  geom_line() + theme(legend.position="none") + ylab("block goal") +
  xlab("") + scale_x_discrete(labels=c("block 1", "block 2", "block 3", "block 4")) + ylim(0,70)
p1

p2 <- misc_data_wide %>%
  filter(subID %in% controls) %>%
  select(-interventionQuizAnswer, -interventionReadingTime) %>%
  melt(id.col="subID") %>%
  arrange(variable) %>%
  mutate(variable = factor(variable, 
                           levels=c("block0answer", "block1answer", "block2answer", "block3answer"))) %>%
  ggplot(aes(x=variable, y=value, group=subID, fill=subID, colour=subID)) +
  geom_point() +
  geom_line() + theme(legend.position="none") + ylab("game liking rating") +
  xlab("") + scale_x_discrete(labels=c("block 1", "block 2", "block 3", "block 4")) + ylim(0,100)
p2

# corr between achievement and goals
tmp <- data_long %>%
  group_by(subID, condition) %>%
  summarise(block0coins = coinsRunningTotal[11],
         block1coins = coinsRunningTotal[22],
         block2coins = coinsRunningTotal[33],
         block3coins = coinsRunningTotal[44])
misc_data_wide <- merge(misc_data_wide, tmp, by = "subID") 

p3 <- misc_data_wide %>%
  filter(!condition=="baseline") %>%
  dplyr::select(-interventionQuizAnswer, -interventionReadingTime) %>%
  melt(idcol="subID") %>%
  separate(variable, into = c("blockNo", "variable"), sep = 6) %>%
  pivot_wider(id_cols=c("subID","blockNo","condition"), names_from = "variable", 
              values_from = "value") %>%
  #filter(!blockNo=="block0") %>%
  ggplot(aes(x=answer, y=coins, colour=condition, fill=condition)) +
  geom_abline(slope = 1, linetype="dashed", colour="grey") +
  geom_point() +
  geom_smooth(method = "lm", se=TRUE, alpha=.2, formula = y~x) +
  theme_minimal() + theme(legend.position="none") +
  scale_colour_manual(values=colours3) + 
  scale_fill_manual(values=colours3) +
  facet_grid(rows=vars(blockNo), cols=vars(condition), scales="free") + ylim(0,70)
p3


# run lme model on answers data 
data_aov2 <- misc_data_wide %>%
    mutate(group = ifelse((subID %in% controls), "control", "planning")) %>%
  dplyr::select(subID, group, block0answer, block1answer, block2answer, block3answer) %>%
  melt(id.vars=c("subID", "group")) %>%
  mutate(variable = recode(variable, 
                           'block0answer'=0, "block1answer"=1, "block2answer"=2, "block3answer"=3))

data_lm <- data_aov2 %>%
  mutate(block = as.factor(variable))
lme1 <- lmer(value ~ group*block + ( 1 | subID ), data=data_lm)
anova(lme1)
emmeans(lme1, list(pairwise ~ group*block), adjust = "tukey") #, pbkrtest.limit = 8800
```
